/*
Copyright 2021 The k8gb Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

package k8s

/*
Copyright 2021 The k8gb Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
)

// Testee public test structure

type arnold struct {
	// int value
	id int `annotation:"controller.example.com/id, require=true"` //nolint:unused
	// float value
	Budget float64 `annotation:"controller.example.com/budget, protected=true, default=500.1"`
	// string value
	Name string `annotation:"controller.example.com/Name"`
	// private field
	surname string `annotation:"controller.example.com/surname, default=Schwarzenegger"`
	// slice value
	Ranks []string `annotation:"controller.example.com/ranks"`
	// bool value
	Armed bool `annotation:"controller.example.com/armed,protected=true"`
	// nested structure
	Inventory struct {
		//
		Rope string `annotation:"controller.example.com/rope, require=true"`
		//
		paperWithSecretKey string `annotation:"controller.example.com/secret, require=true"`
	}
}

func (a *arnold) String() string {
	if a.Armed {
		return fmt.Sprintf("Machine Gun %s %s, ranks:%v, inventory: [%s, %s], budget: %v", a.Name, a.surname, a.Ranks, a.Inventory.Rope, a.Inventory.paperWithSecretKey, a.Budget)
	}
	return fmt.Sprintf("%s %s in full retreat, ranks:%v, inventory: [%s, %s], budget: %v", a.Name, a.surname, a.Ranks, a.Inventory.Rope, a.Inventory.paperWithSecretKey, a.Budget)
}

func TestBind(t *testing.T) {
	// arrange
	getPredefinedInput := func() (map[string]string, *arnold) {
		return map[string]string{
			"controller.example.com/id":      "1500",
			"controller.example.com/Name":    "Arnold",
			"controller.example.com/surname": "Rimmer",
			"controller.example.com/ranks":   "officer1,capitan,general,major",
			"controller.example.com/armed":   "false",
			"controller.example.com/rope":    "dipper rope",
			"controller.example.com/secret":  "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY",
		}, new(arnold)
	}

	tests := []struct {
		name           string
		expectedResult string
		expectedError  bool
		modifier       func(map[string]string, *arnold)
	}{
		{
			name:           "private field",
			expectedResult: "Arnold Rimmer in full retreat, ranks:[officer1 capitan general major], inventory: [dipper rope, wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY], budget: 500.1",
			expectedError:  false,
			modifier:       func(m map[string]string, a *arnold) {},
		},
		{
			name:           "protected field",
			expectedResult: "Machine Gun Arnold Rimmer, ranks:[officer1 capitan general major], inventory: [dipper rope, wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY], budget: 500.1",
			expectedError:  false,
			modifier: func(m map[string]string, a *arnold) {
				a.Armed = true
			},
		},
		{
			name:          "missing required field",
			expectedError: true,
			modifier: func(m map[string]string, a *arnold) {
				delete(m, "controller.example.com/id")
			},
		},
		{
			name:          "empty required field",
			expectedError: true,
			modifier: func(m map[string]string, a *arnold) {
				m["controller.example.com/id"] = ""
			},
		},
		{
			name:           "empty non required field",
			expectedError:  false,
			expectedResult: "Arnold  in full retreat, ranks:[officer1 capitan general major], inventory: [dipper rope, wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY], budget: 500.1",
			modifier: func(m map[string]string, a *arnold) {
				m["controller.example.com/surname"] = ""
			},
		},
		{
			name:           "default field override",
			expectedError:  false,
			expectedResult: "Arnold Rimmer in full retreat, ranks:[officer1 capitan general major], inventory: [dipper rope, wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY], budget: 500.1",
			modifier: func(m map[string]string, a *arnold) {
			},
		},
		{
			name:           "default field doesn't exist",
			expectedError:  false,
			expectedResult: "Arnold Schwarzenegger in full retreat, ranks:[officer1 capitan general major], inventory: [dipper rope, wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY], budget: 500.1",
			modifier: func(m map[string]string, a *arnold) {
				delete(m, "controller.example.com/surname")
			},
		},
		{
			name:           "default field empty",
			expectedError:  false,
			expectedResult: "Arnold  in full retreat, ranks:[officer1 capitan general major], inventory: [dipper rope, wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY], budget: 500.1",
			modifier: func(m map[string]string, a *arnold) {
				m["controller.example.com/surname"] = ""
			},
		},
		{
			name:           "protected field filled",
			expectedError:  false,
			expectedResult: "Arnold Rimmer in full retreat, ranks:[officer1 capitan general major], inventory: [dipper rope, wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY], budget: 180.3",
			modifier: func(m map[string]string, a *arnold) {
				m["controller.example.com/budget"] = "1000"
				a.Budget = 180.3
			},
		},
		{
			name:           "protected default field specified, but unfilled ",
			expectedError:  false,
			expectedResult: "Arnold Rimmer in full retreat, ranks:[officer1 capitan general major], inventory: [dipper rope, wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY], budget: 1000",
			modifier: func(m map[string]string, a *arnold) {
				m["controller.example.com/budget"] = "1000"
			},
		},
		{
			name:           "protected default field empty and unfilled",
			expectedError:  true,
			expectedResult: "Arnold Rimmer in full retreat, ranks:[officer1 capitan general major], inventory: [dipper rope, wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY], budget: 500.1",
			modifier: func(m map[string]string, a *arnold) {
				// Budget float64 `annotation:"controller.example.com/budget, protected=true, default=500.1"`
				m["controller.example.com/budget"] = ""
			},
		},
		{
			name:           "protected default field empty and filled",
			expectedError:  false,
			expectedResult: "Arnold Rimmer in full retreat, ranks:[officer1 capitan general major], inventory: [dipper rope, wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY], budget: 20.1",
			modifier: func(m map[string]string, a *arnold) {
				// Budget float64 `annotation:"controller.example.com/budget, protected=true, default=500.1"`
				m["controller.example.com/budget"] = ""
				a.Budget = 20.1
			},
		},
		{
			name:          "empty map",
			expectedError: true,
			modifier: func(m map[string]string, a *arnold) {
				for k := range m {
					delete(m, k)
				}
			},
		},
	}

	// act
	// assert
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			m, a := getPredefinedInput()
			test.modifier(m, a)
			err := Bind(m, a)
			assert.Equal(t, test.expectedError, err != nil)
			if !test.expectedError {
				assert.Equal(t, test.expectedResult, a.String())
			}
		})
	}
}

func TestBreaking(t *testing.T) {
	tests := []struct {
		name          string
		m             map[string]string
		s             interface{}
		expectedError bool
	}{
		{name: "nil map", m: nil, s: &arnold{}, expectedError: false},
		{name: "nil structure", m: map[string]string{}, s: nil, expectedError: true},
	}
	// act
	// assert
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := Bind(test.m, test.s)
			assert.Equal(t, err != nil, test.expectedError)
		})
	}
}

func TestInt(t *testing.T) {
	type s struct {
		Public                  int `annotation:"public"`
		private                 int `annotation:"private"`
		Protected               int `annotation:"protected, protected=true"`
		Required                int `annotation:"require, require=true"`
		Default                 int `annotation:"default, default=1000"`
		privateDefaultProtected int `annotation:"privateDefaultProtected, default=1000, protected=true"`
		Nested                  struct {
			Value int `annotation:"nested, default=100"`
		}
	}

	var tests = []struct {
		name          string
		m             map[string]string
		s             *s
		expectedError bool
		a             func(s *s)
	}{
		{name: "Public", s: &s{}, expectedError: false, m: map[string]string{"require": "10", "public": "1"},
			a: func(s *s) {
				assert.Equal(t, 1, s.Public)
				assert.Equal(t, 10, s.Required)
				assert.Equal(t, 1000, s.Default)
			}},
		{name: "private", s: &s{}, expectedError: false, m: map[string]string{"require": "10", "private": "2"},
			a: func(s *s) {
				assert.Equal(t, 2, s.private)
				assert.Equal(t, 10, s.Required)
				assert.Equal(t, 1000, s.Default)
			}},
		{name: "Protected Off", s: &s{}, expectedError: false, m: map[string]string{"require": "10", "protected": "3"},
			a: func(s *s) {
				assert.Equal(t, 3, s.Protected)
				assert.Equal(t, 10, s.Required)
			}},
		{name: "Protected On", s: &s{Protected: 100}, expectedError: false, m: map[string]string{"require": "10", "protected": "3"},
			a: func(s *s) {
				assert.Equal(t, 100, s.Protected)
				assert.Equal(t, 10, s.Required)
				assert.Equal(t, 1000, s.Default)
			}},
		{name: "Unprotected", s: &s{Required: 100}, expectedError: false, m: map[string]string{"require": "10"},
			a: func(s *s) {
				assert.Equal(t, 10, s.Required)
				assert.Equal(t, 1000, s.Default)
			}},
		{name: "Required On", s: &s{}, expectedError: false, m: map[string]string{"require": "10"},
			a: func(s *s) {
				assert.Equal(t, 10, s.Required)
				assert.Equal(t, 1000, s.Default)
			}},
		{name: "Required Off", s: &s{}, expectedError: true, m: map[string]string{},
			a: func(s *s) {}},
		{name: "Default On", s: &s{}, expectedError: false, m: map[string]string{"require": "10"},
			a: func(s *s) {
				assert.Equal(t, 10, s.Required)
				assert.Equal(t, 1000, s.Default)
			}},
		{name: "Default Off", s: &s{}, expectedError: false, m: map[string]string{"require": "10", "default": "4"},
			a: func(s *s) {
				assert.Equal(t, 10, s.Required)
				assert.Equal(t, 4, s.Default)
			}},
		{name: "Default On + unprotected", s: &s{Default: 50}, expectedError: false, m: map[string]string{"require": "10"},
			a: func(s *s) {
				assert.Equal(t, 10, s.Required)
				assert.Equal(t, 1000, s.Default)
			}},
		{name: "private default protected 1", s: &s{privateDefaultProtected: 5}, expectedError: false, m: map[string]string{"require": "10"},
			a: func(s *s) {
				assert.Equal(t, 5, s.privateDefaultProtected)
				assert.Equal(t, 1000, s.Default)
			}},
		{name: "private default protected 2", s: &s{}, expectedError: false, m: map[string]string{"require": "10"},
			a: func(s *s) {
				assert.Equal(t, 1000, s.privateDefaultProtected)
				assert.Equal(t, 1000, s.Default)
				assert.Equal(t, 10, s.Required)
			}},
		{name: "private default protected 3", s: &s{}, expectedError: false, m: map[string]string{"require": "10", "privateDefaultProtected": "5"},
			a: func(s *s) {
				assert.Equal(t, 5, s.privateDefaultProtected)
				assert.Equal(t, 1000, s.Default)
				assert.Equal(t, 10, s.Required)
			}},
		{name: "nested", s: &s{}, expectedError: false, m: map[string]string{"require": "10", "nested": "100"},
			a: func(s *s) {
				assert.Equal(t, 100, s.Nested.Value)
				assert.Equal(t, 10, s.Required)
				assert.Equal(t, 1000, s.Default)
			}},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := Bind(test.m, test.s)
			assert.Equal(t, test.expectedError, err != nil)
			test.a(test.s)
		})
	}
}

func TestFloat64(t *testing.T) {
	type s struct {
		Public                  float64 `annotation:"public"`
		private                 float64 `annotation:"private"`
		Protected               float64 `annotation:"protected, protected=true"`
		Required                float64 `annotation:"require, require=true"`
		Default                 float64 `annotation:"default, default=1000"`
		privateDefaultProtected float64 `annotation:"privateDefaultProtected, default=1000, protected=true"`
		Nested                  struct {
			Value float64 `annotation:"nested, default=100"`
		}
	}

	var tests = []struct {
		name          string
		m             map[string]string
		s             *s
		expectedError bool
		a             func(s *s)
	}{
		{name: "Public", s: &s{}, expectedError: false, m: map[string]string{"require": "10", "public": "1"},
			a: func(s *s) {
				assert.Equal(t, 1., s.Public)
				assert.Equal(t, 10., s.Required)
				assert.Equal(t, 1000., s.Default)
			}},
		{name: "private", s: &s{}, expectedError: false, m: map[string]string{"require": "10", "private": "2"},
			a: func(s *s) {
				assert.Equal(t, 2., s.private)
				assert.Equal(t, 10., s.Required)
				assert.Equal(t, 1000., s.Default)
			}},
		{name: "Protected Off", s: &s{}, expectedError: false, m: map[string]string{"require": "10", "protected": "3"},
			a: func(s *s) {
				assert.Equal(t, 3., s.Protected)
				assert.Equal(t, 10., s.Required)
			}},
		{name: "Protected On", s: &s{Protected: 100.}, expectedError: false, m: map[string]string{"require": "10", "protected": "3"},
			a: func(s *s) {
				assert.Equal(t, 100., s.Protected)
				assert.Equal(t, 10., s.Required)
				assert.Equal(t, 1000., s.Default)
			}},
		{name: "Unprotected", s: &s{Required: 100.}, expectedError: false, m: map[string]string{"require": "10"},
			a: func(s *s) {
				assert.Equal(t, 10., s.Required)
				assert.Equal(t, 1000., s.Default)
			}},
		{name: "Required On", s: &s{}, expectedError: false, m: map[string]string{"require": "10"},
			a: func(s *s) {
				assert.Equal(t, 10., s.Required)
				assert.Equal(t, 1000., s.Default)
			}},
		{name: "Required Off", s: &s{}, expectedError: true, m: map[string]string{},
			a: func(s *s) {}},
		{name: "Default On", s: &s{}, expectedError: false, m: map[string]string{"require": "10"},
			a: func(s *s) {
				assert.Equal(t, 10., s.Required)
				assert.Equal(t, 1000., s.Default)
			}},
		{name: "Default Off", s: &s{}, expectedError: false, m: map[string]string{"require": "10", "default": "4"},
			a: func(s *s) {
				assert.Equal(t, 10., s.Required)
				assert.Equal(t, 4., s.Default)
			}},
		{name: "Default On + unprotected", s: &s{Default: 50}, expectedError: false, m: map[string]string{"require": "10"},
			a: func(s *s) {
				assert.Equal(t, 10., s.Required)
				assert.Equal(t, 1000., s.Default)
			}},
		{name: "private default protected 1", s: &s{privateDefaultProtected: 5}, expectedError: false, m: map[string]string{"require": "10"},
			a: func(s *s) {
				assert.Equal(t, 5., s.privateDefaultProtected)
				assert.Equal(t, 1000., s.Default)
			}},
		{name: "private default protected 2", s: &s{}, expectedError: false, m: map[string]string{"require": "10"},
			a: func(s *s) {
				assert.Equal(t, 1000., s.privateDefaultProtected)
				assert.Equal(t, 1000., s.Default)
				assert.Equal(t, 10., s.Required)
			}},
		{name: "private default protected 3", s: &s{}, expectedError: false, m: map[string]string{"require": "10", "privateDefaultProtected": "5"},
			a: func(s *s) {
				assert.Equal(t, 5., s.privateDefaultProtected)
				assert.Equal(t, 1000., s.Default)
				assert.Equal(t, 10., s.Required)
			}},
		{name: "nested", s: &s{}, expectedError: false, m: map[string]string{"require": "10", "nested": "100"},
			a: func(s *s) {
				assert.Equal(t, 100., s.Nested.Value)
				assert.Equal(t, 10., s.Required)
				assert.Equal(t, 1000., s.Default)
			}},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := Bind(test.m, test.s)
			assert.Equal(t, test.expectedError, err != nil)
			test.a(test.s)
		})
	}
}

func TestString(t *testing.T) {
	type s struct {
		Public                  string `annotation:"public"`
		private                 string `annotation:"private"`
		Protected               string `annotation:"protected, protected=true"`
		Required                string `annotation:"require, require=true"`
		Default                 string `annotation:"default, default=rootDefault"`
		privateDefaultProtected string `annotation:"privateDefaultProtected, default=rootDefault, protected=true"`
		Nested                  struct {
			Value string `annotation:"nested, default=nestedDefault"`
		}
	}

	var tests = []struct {
		name          string
		m             map[string]string
		s             *s
		expectedError bool
		a             func(s *s)
	}{
		{name: "Public", s: &s{}, expectedError: false, m: map[string]string{"require": "require", "public": "public"},
			a: func(s *s) {
				assert.Equal(t, "public", s.Public)
				assert.Equal(t, "require", s.Required)
				assert.Equal(t, "rootDefault", s.Default)
			}},
		{name: "private", s: &s{}, expectedError: false, m: map[string]string{"require": "require", "private": "private"},
			a: func(s *s) {
				assert.Equal(t, "private", s.private)
				assert.Equal(t, "require", s.Required)
				assert.Equal(t, "rootDefault", s.Default)
			}},
		{name: "Protected Off", s: &s{}, expectedError: false, m: map[string]string{"require": "require", "protected": "protected"},
			a: func(s *s) {
				assert.Equal(t, "protected", s.Protected)
				assert.Equal(t, "require", s.Required)
			}},
		{name: "Protected On", s: &s{Protected: "protected"}, expectedError: false, m: map[string]string{"require": "require", "protected": "protected"},
			a: func(s *s) {
				assert.Equal(t, "protected", s.Protected)
				assert.Equal(t, "require", s.Required)
				assert.Equal(t, "rootDefault", s.Default)
			}},
		{name: "Unprotected", s: &s{Required: "blah"}, expectedError: false, m: map[string]string{"require": "require"},
			a: func(s *s) {
				assert.Equal(t, "require", s.Required)
				assert.Equal(t, "rootDefault", s.Default)
			}},
		{name: "Required On", s: &s{}, expectedError: false, m: map[string]string{"require": "require"},
			a: func(s *s) {
				assert.Equal(t, "require", s.Required)
				assert.Equal(t, "rootDefault", s.Default)
			}},
		{name: "Required Off", s: &s{}, expectedError: true, m: map[string]string{},
			a: func(s *s) {}},
		{name: "Default On", s: &s{}, expectedError: false, m: map[string]string{"require": "require"},
			a: func(s *s) {
				assert.Equal(t, "require", s.Required)
				assert.Equal(t, "rootDefault", s.Default)
			}},
		{name: "Default Off", s: &s{}, expectedError: false, m: map[string]string{"require": "require", "default": "4"},
			a: func(s *s) {
				assert.Equal(t, "require", s.Required)
				assert.Equal(t, "4", s.Default)
			}},
		{name: "Default On + unprotected", s: &s{Default: "50"}, expectedError: false, m: map[string]string{"require": "require"},
			a: func(s *s) {
				assert.Equal(t, "require", s.Required)
				assert.Equal(t, "rootDefault", s.Default)
			}},
		{name: "private default protected 1", s: &s{privateDefaultProtected: "5"}, expectedError: false, m: map[string]string{"require": "require"},
			a: func(s *s) {
				assert.Equal(t, "require", s.Required)
				assert.Equal(t, "5", s.privateDefaultProtected)
				assert.Equal(t, "rootDefault", s.Default)
			}},
		{name: "private default protected 2", s: &s{}, expectedError: false, m: map[string]string{"require": "require"},
			a: func(s *s) {
				assert.Equal(t, "require", s.Required)
				assert.Equal(t, "rootDefault", s.privateDefaultProtected)
				assert.Equal(t, "rootDefault", s.Default)
			}},
		{name: "private default protected 3", s: &s{}, expectedError: false, m: map[string]string{"require": "require", "privateDefaultProtected": "5"},
			a: func(s *s) {
				assert.Equal(t, "5", s.privateDefaultProtected)
				assert.Equal(t, "rootDefault", s.Default)
				assert.Equal(t, "require", s.Required)
			}},
		{name: "nested", s: &s{}, expectedError: false, m: map[string]string{"require": "require", "nested": "nestedDefault"},
			a: func(s *s) {
				assert.Equal(t, "require", s.Required)
				assert.Equal(t, "nestedDefault", s.Nested.Value)
				assert.Equal(t, "rootDefault", s.Default)
			}},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := Bind(test.m, test.s)
			assert.Equal(t, test.expectedError, err != nil)
			test.a(test.s)
		})
	}
}

func TestBool(t *testing.T) {
	type s struct {
		Public                  bool `annotation:"public"`
		private                 bool `annotation:"private"`
		Protected               bool `annotation:"protected, protected=true"`
		Required                bool `annotation:"require, require=true"`
		Default                 bool `annotation:"default, default=true"`
		privateDefaultProtected bool `annotation:"privateDefaultProtected, default=true, protected=true"`
		Nested                  struct {
			Value bool `annotation:"nested, default=true"`
		}
	}

	var tests = []struct {
		name          string
		m             map[string]string
		s             *s
		expectedError bool
		a             func(s *s)
	}{
		{name: "Public", s: &s{}, expectedError: false, m: map[string]string{"require": "true", "public": "true"},
			a: func(s *s) {
				assert.Equal(t, true, s.Public)
				assert.Equal(t, true, s.Required)
				assert.Equal(t, true, s.Default)
			}},
		{name: "private", s: &s{}, expectedError: false, m: map[string]string{"require": "true", "private": "true"},
			a: func(s *s) {
				assert.Equal(t, true, s.private)
				assert.Equal(t, true, s.Required)
				assert.Equal(t, true, s.Default)
			}},
		{name: "Protected Off", s: &s{}, expectedError: false, m: map[string]string{"require": "true", "protected": "true"},
			a: func(s *s) {
				assert.Equal(t, false, s.Protected)
				assert.Equal(t, true, s.Required)
			}},
		{name: "Protected On", s: &s{Protected: true}, expectedError: false, m: map[string]string{"require": "true", "protected": "true"},
			a: func(s *s) {
				assert.Equal(t, true, s.Protected)
				assert.Equal(t, true, s.Required)
				assert.Equal(t, true, s.Default)
			}},
		{name: "Unprotected", s: &s{Required: true}, expectedError: false, m: map[string]string{"require": "true"},
			a: func(s *s) {
				assert.Equal(t, true, s.Required)
				assert.Equal(t, true, s.Default)
			}},
		{name: "Required On", s: &s{}, expectedError: false, m: map[string]string{"require": "true"},
			a: func(s *s) {
				assert.Equal(t, true, s.Required)
				assert.Equal(t, true, s.Default)
			}},
		{name: "Required Off", s: &s{}, expectedError: true, m: map[string]string{},
			a: func(s *s) {}},
		{name: "Default On", s: &s{}, expectedError: false, m: map[string]string{"require": "true"},
			a: func(s *s) {
				assert.Equal(t, true, s.Required)
				assert.Equal(t, true, s.Default)
			}},
		{name: "Default Off", s: &s{}, expectedError: false, m: map[string]string{"require": "true", "default": "true"},
			a: func(s *s) {
				assert.Equal(t, true, s.Required)
				assert.Equal(t, true, s.Default)
			}},
		{name: "Default On + unprotected", s: &s{Default: true}, expectedError: false, m: map[string]string{"require": "true"},
			a: func(s *s) {
				assert.Equal(t, true, s.Required)
				assert.Equal(t, true, s.Default)
			}},
		{name: "private default protected 1", s: &s{privateDefaultProtected: true}, expectedError: false, m: map[string]string{"require": "true"},
			a: func(s *s) {
				assert.Equal(t, true, s.privateDefaultProtected)
				assert.Equal(t, true, s.Default)
			}},
		{name: "private default protected 2", s: &s{}, expectedError: false, m: map[string]string{"require": "true"},
			a: func(s *s) {
				assert.Equal(t, false, s.privateDefaultProtected)
				assert.Equal(t, true, s.Default)
				assert.Equal(t, true, s.Required)
			}},
		{name: "private default protected 3", s: &s{}, expectedError: false, m: map[string]string{"require": "true", "privateDefaultProtected": "true"},
			a: func(s *s) {
				assert.Equal(t, false, s.privateDefaultProtected)
				assert.Equal(t, true, s.Default)
				assert.Equal(t, true, s.Required)
			}},
		{name: "nested", s: &s{}, expectedError: false, m: map[string]string{"require": "true", "nested": "true"},
			a: func(s *s) {
				assert.Equal(t, true, s.Nested.Value)
				assert.Equal(t, true, s.Required)
				assert.Equal(t, true, s.Default)
			}},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := Bind(test.m, test.s)
			assert.Equal(t, test.expectedError, err != nil)
			test.a(test.s)
		})
	}
}

func TestIntSlice(t *testing.T) {
	type s struct {
		Public                  []int `annotation:"public"`
		private                 []int `annotation:"private"`
		Protected               []int `annotation:"protected, protected=true"`
		Required                []int `annotation:"require, require=true"`
		Default                 []int `annotation:"default, default=[1000,1001]"`
		privateDefaultProtected []int `annotation:"privateDefaultProtected, default=[1000,1001], protected=true"`
		Nested                  struct {
			Value []int `annotation:"nested, default=[100,101]"`
		}
	}

	var tests = []struct {
		name          string
		m             map[string]string
		s             *s
		expectedError bool
		a             func(s *s)
	}{
		{name: "Public", s: &s{}, expectedError: false, m: map[string]string{"require": "10,11", "public": "1,2"},
			a: func(s *s) {
				assert.Equal(t, []int{1, 2}, s.Public)
				assert.Equal(t, []int{10, 11}, s.Required)
				assert.Equal(t, []int{1000, 1001}, s.Default)
			}},
		{name: "private", s: &s{}, expectedError: false, m: map[string]string{"require": "10", "private": "2"},
			a: func(s *s) {
				assert.Equal(t, []int{2}, s.private)
				assert.Equal(t, []int{10}, s.Required)
				assert.Equal(t, []int{1000, 1001}, s.Default)
			}},
		{name: "Protected Off", s: &s{}, expectedError: false, m: map[string]string{"require": "10,11", "protected": "3,4"},
			a: func(s *s) {
				assert.Equal(t, []int{3, 4}, s.Protected)
				assert.Equal(t, []int{10, 11}, s.Required)
			}},
		{name: "Protected On", s: &s{Protected: []int{100, 101}}, expectedError: false, m: map[string]string{"require": "10", "protected": "3,4"},
			a: func(s *s) {
				assert.Equal(t, []int{100, 101}, s.Protected)
				assert.Equal(t, []int{10}, s.Required)
				assert.Equal(t, []int{1000, 1001}, s.Default)
			}},
		{name: "Protected On Empty", s: &s{Protected: []int{}}, expectedError: false, m: map[string]string{"require": "10", "protected": "3,4"},
			a: func(s *s) {
				assert.Equal(t, []int{}, s.Protected)
				assert.Equal(t, []int{10}, s.Required)
				assert.Equal(t, []int{1000, 1001}, s.Default)
			}},
		{name: "Protected On Nil", s: &s{Protected: nil}, expectedError: false, m: map[string]string{"require": "10", "protected": "3,4"},
			a: func(s *s) {
				assert.Equal(t, []int{3, 4}, s.Protected)
				assert.Equal(t, []int{10}, s.Required)
				assert.Equal(t, []int{1000, 1001}, s.Default)
			}},
		{name: "Unprotected", s: &s{Required: []int{100}}, expectedError: false, m: map[string]string{"require": "10,11"},
			a: func(s *s) {
				assert.Equal(t, []int{10, 11}, s.Required)
				assert.Equal(t, []int{1000, 1001}, s.Default)
			}},
		{name: "Required On", s: &s{}, expectedError: false, m: map[string]string{"require": "10,11"},
			a: func(s *s) {
				assert.Equal(t, []int{10, 11}, s.Required)
				assert.Equal(t, []int{1000, 1001}, s.Default)
			}},
		{name: "Required On Empty", s: &s{}, expectedError: false, m: map[string]string{"require": ""},
			a: func(s *s) {
				assert.Equal(t, []int{}, s.Required)
				assert.Equal(t, []int{1000, 1001}, s.Default)
			}},
		{name: "Required Off (Nil)", s: &s{}, expectedError: true, m: map[string]string{},
			a: func(s *s) {}},
		{name: "Default On", s: &s{}, expectedError: false, m: map[string]string{"require": "10"},
			a: func(s *s) {
				assert.Equal(t, []int{10}, s.Required)
				assert.Equal(t, []int{1000, 1001}, s.Default)
			}},
		{name: "Default Off", s: &s{}, expectedError: false, m: map[string]string{"require": "10", "default": "4,5"},
			a: func(s *s) {
				assert.Equal(t, []int{10}, s.Required)
				assert.Equal(t, []int{4, 5}, s.Default)
			}},
		{name: "Default On + unprotected", s: &s{Default: []int{50, 51}}, expectedError: false, m: map[string]string{"require": "10"},
			a: func(s *s) {
				assert.Equal(t, []int{10}, s.Required)
				assert.Equal(t, []int{1000, 1001}, s.Default)
			}},
		{name: "private default protected 1", s: &s{privateDefaultProtected: []int{5, 6}}, expectedError: false, m: map[string]string{"require": "10"},
			a: func(s *s) {
				assert.Equal(t, []int{5, 6}, s.privateDefaultProtected)
				assert.Equal(t, []int{1000, 1001}, s.Default)
			}},
		{name: "private default protected 2", s: &s{}, expectedError: false, m: map[string]string{"require": "10"},
			a: func(s *s) {
				assert.Equal(t, []int{1000, 1001}, s.privateDefaultProtected)
				assert.Equal(t, []int{1000, 1001}, s.Default)
				assert.Equal(t, []int{10}, s.Required)
			}},
		{name: "private default protected 3", s: &s{}, expectedError: false, m: map[string]string{"require": "10", "privateDefaultProtected": "5"},
			a: func(s *s) {
				assert.Equal(t, []int{5}, s.privateDefaultProtected)
				assert.Equal(t, []int{1000, 1001}, s.Default)
				assert.Equal(t, []int{10}, s.Required)
			}},
		{name: "nested", s: &s{}, expectedError: false, m: map[string]string{"require": "10", "nested": "100,110"},
			a: func(s *s) {
				assert.Equal(t, []int{100, 110}, s.Nested.Value)
				assert.Equal(t, []int{10}, s.Required)
				assert.Equal(t, []int{1000, 1001}, s.Default)
			}},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := Bind(test.m, test.s)
			assert.Equal(t, test.expectedError, err != nil)
			test.a(test.s)
		})
	}
}

func TestFloat64Slice(t *testing.T) {
	type s struct {
		Public                  []float64 `annotation:"public"`
		private                 []float64 `annotation:"private"`
		Protected               []float64 `annotation:"protected, protected=true"`
		Required                []float64 `annotation:"require, require=true"`
		Default                 []float64 `annotation:"default, default=[1000,1001]"`
		privateDefaultProtected []float64 `annotation:"privateDefaultProtected, default=[1000,1001], protected=true"`
		Nested                  struct {
			Value []float64 `annotation:"nested, default=[100,101]"`
		}
	}

	var tests = []struct {
		name          string
		m             map[string]string
		s             *s
		expectedError bool
		a             func(s *s)
	}{
		{name: "Public", s: &s{}, expectedError: false, m: map[string]string{"require": "10,11", "public": "1,2"},
			a: func(s *s) {
				assert.Equal(t, []float64{1, 2}, s.Public)
				assert.Equal(t, []float64{10, 11}, s.Required)
				assert.Equal(t, []float64{1000, 1001}, s.Default)
			}},
		{name: "private", s: &s{}, expectedError: false, m: map[string]string{"require": "10", "private": "2"},
			a: func(s *s) {
				assert.Equal(t, []float64{2}, s.private)
				assert.Equal(t, []float64{10}, s.Required)
				assert.Equal(t, []float64{1000, 1001}, s.Default)
			}},
		{name: "Protected Off", s: &s{}, expectedError: false, m: map[string]string{"require": "10,11", "protected": "3,4"},
			a: func(s *s) {
				assert.Equal(t, []float64{3, 4}, s.Protected)
				assert.Equal(t, []float64{10, 11}, s.Required)
			}},
		{name: "Protected On", s: &s{Protected: []float64{100, 101}}, expectedError: false, m: map[string]string{"require": "10", "protected": "3,4"},
			a: func(s *s) {
				assert.Equal(t, []float64{100, 101}, s.Protected)
				assert.Equal(t, []float64{10}, s.Required)
				assert.Equal(t, []float64{1000, 1001}, s.Default)
			}},
		{name: "Protected On Empty", s: &s{Protected: []float64{}}, expectedError: false, m: map[string]string{"require": "10", "protected": "3,4"},
			a: func(s *s) {
				assert.Equal(t, []float64{}, s.Protected)
				assert.Equal(t, []float64{10}, s.Required)
				assert.Equal(t, []float64{1000, 1001}, s.Default)
			}},
		{name: "Protected On Nil", s: &s{Protected: nil}, expectedError: false, m: map[string]string{"require": "10", "protected": "3,4"},
			a: func(s *s) {
				assert.Equal(t, []float64{3, 4}, s.Protected)
				assert.Equal(t, []float64{10}, s.Required)
				assert.Equal(t, []float64{1000, 1001}, s.Default)
			}},
		{name: "Unprotected", s: &s{Required: []float64{100}}, expectedError: false, m: map[string]string{"require": "10,11"},
			a: func(s *s) {
				assert.Equal(t, []float64{10, 11}, s.Required)
				assert.Equal(t, []float64{1000, 1001}, s.Default)
			}},
		{name: "Required On", s: &s{}, expectedError: false, m: map[string]string{"require": "10,11"},
			a: func(s *s) {
				assert.Equal(t, []float64{10, 11}, s.Required)
				assert.Equal(t, []float64{1000, 1001}, s.Default)
			}},
		{name: "Required On Empty", s: &s{}, expectedError: false, m: map[string]string{"require": ""},
			a: func(s *s) {
				assert.Equal(t, []float64{}, s.Required)
				assert.Equal(t, []float64{1000, 1001}, s.Default)
			}},
		{name: "Required Off (Nil)", s: &s{}, expectedError: true, m: map[string]string{},
			a: func(s *s) {}},
		{name: "Default On", s: &s{}, expectedError: false, m: map[string]string{"require": "10"},
			a: func(s *s) {
				assert.Equal(t, []float64{10}, s.Required)
				assert.Equal(t, []float64{1000, 1001}, s.Default)
			}},
		{name: "Default Off", s: &s{}, expectedError: false, m: map[string]string{"require": "10", "default": "4,5"},
			a: func(s *s) {
				assert.Equal(t, []float64{10}, s.Required)
				assert.Equal(t, []float64{4, 5}, s.Default)
			}},
		{name: "Default On + unprotected", s: &s{Default: []float64{50, 51}}, expectedError: false, m: map[string]string{"require": "10"},
			a: func(s *s) {
				assert.Equal(t, []float64{10}, s.Required)
				assert.Equal(t, []float64{1000, 1001}, s.Default)
			}},
		{name: "private default protected 1", s: &s{privateDefaultProtected: []float64{5, 6}}, expectedError: false, m: map[string]string{"require": "10"},
			a: func(s *s) {
				assert.Equal(t, []float64{5, 6}, s.privateDefaultProtected)
				assert.Equal(t, []float64{1000, 1001}, s.Default)
			}},
		{name: "private default protected 2", s: &s{}, expectedError: false, m: map[string]string{"require": "10"},
			a: func(s *s) {
				assert.Equal(t, []float64{1000, 1001}, s.privateDefaultProtected)
				assert.Equal(t, []float64{1000, 1001}, s.Default)
				assert.Equal(t, []float64{10}, s.Required)
			}},
		{name: "private default protected 3", s: &s{}, expectedError: false, m: map[string]string{"require": "10", "privateDefaultProtected": "5"},
			a: func(s *s) {
				assert.Equal(t, []float64{5}, s.privateDefaultProtected)
				assert.Equal(t, []float64{1000, 1001}, s.Default)
				assert.Equal(t, []float64{10}, s.Required)
			}},
		{name: "nested", s: &s{}, expectedError: false, m: map[string]string{"require": "10", "nested": "100,110"},
			a: func(s *s) {
				assert.Equal(t, []float64{100, 110}, s.Nested.Value)
				assert.Equal(t, []float64{10}, s.Required)
				assert.Equal(t, []float64{1000, 1001}, s.Default)
			}},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := Bind(test.m, test.s)
			assert.Equal(t, test.expectedError, err != nil)
			test.a(test.s)
		})
	}
}

func TestStringSlice(t *testing.T) {
	type s struct {
		Public                  []string `annotation:"public"`
		private                 []string `annotation:"private"`
		Protected               []string `annotation:"protected, protected=true"`
		Required                []string `annotation:"require, require=true"`
		Default                 []string `annotation:"default, default=[1000,1001]"`
		privateDefaultProtected []string `annotation:"privateDefaultProtected, default=[1000,1001], protected=true"`
		Nested                  struct {
			Value []string `annotation:"nested, default=[100,101]"`
		}
	}

	var tests = []struct {
		name          string
		m             map[string]string
		s             *s
		expectedError bool
		a             func(s *s)
	}{
		{name: "Public", s: &s{}, expectedError: false, m: map[string]string{"require": "10,11", "public": "1,2"},
			a: func(s *s) {
				assert.Equal(t, []string{"1", "2"}, s.Public)
				assert.Equal(t, []string{"10", "11"}, s.Required)
				assert.Equal(t, []string{"1000", "1001"}, s.Default)
			}},
		{name: "private", s: &s{}, expectedError: false, m: map[string]string{"require": "10", "private": "2"},
			a: func(s *s) {
				assert.Equal(t, []string{"2"}, s.private)
				assert.Equal(t, []string{"10"}, s.Required)
				assert.Equal(t, []string{"1000", "1001"}, s.Default)
			}},
		{name: "Protected Off", s: &s{}, expectedError: false, m: map[string]string{"require": "10,11", "protected": "3,4"},
			a: func(s *s) {
				assert.Equal(t, []string{"3", "4"}, s.Protected)
				assert.Equal(t, []string{"10", "11"}, s.Required)
			}},
		{name: "Protected On", s: &s{Protected: []string{"100", "101"}}, expectedError: false, m: map[string]string{"require": "10", "protected": "3,4"},
			a: func(s *s) {
				assert.Equal(t, []string{"100", "101"}, s.Protected)
				assert.Equal(t, []string{"10"}, s.Required)
				assert.Equal(t, []string{"1000", "1001"}, s.Default)
			}},
		{name: "Protected On Empty", s: &s{Protected: []string{}}, expectedError: false, m: map[string]string{"require": "10", "protected": "3,4"},
			a: func(s *s) {
				assert.Equal(t, []string{}, s.Protected)
				assert.Equal(t, []string{"10"}, s.Required)
				assert.Equal(t, []string{"1000", "1001"}, s.Default)
			}},
		{name: "Protected On Nil", s: &s{Protected: nil}, expectedError: false, m: map[string]string{"require": "10", "protected": "3,4"},
			a: func(s *s) {
				assert.Equal(t, []string{"3", "4"}, s.Protected)
				assert.Equal(t, []string{"10"}, s.Required)
				assert.Equal(t, []string{"1000", "1001"}, s.Default)
			}},
		{name: "Unprotected", s: &s{Required: []string{"100"}}, expectedError: false, m: map[string]string{"require": "10,11"},
			a: func(s *s) {
				assert.Equal(t, []string{"10", "11"}, s.Required)
				assert.Equal(t, []string{"1000", "1001"}, s.Default)
			}},
		{name: "Required On", s: &s{}, expectedError: false, m: map[string]string{"require": "10,11"},
			a: func(s *s) {
				assert.Equal(t, []string{"10", "11"}, s.Required)
				assert.Equal(t, []string{"1000", "1001"}, s.Default)
			}},
		{name: "Required On Empty", s: &s{}, expectedError: false, m: map[string]string{"require": ""},
			a: func(s *s) {
				assert.Equal(t, []string{}, s.Required)
				assert.Equal(t, []string{"1000", "1001"}, s.Default)
			}},
		{name: "Required Off (Nil)", s: &s{}, expectedError: true, m: map[string]string{},
			a: func(s *s) {}},
		{name: "Default On", s: &s{}, expectedError: false, m: map[string]string{"require": "10"},
			a: func(s *s) {
				assert.Equal(t, []string{"10"}, s.Required)
				assert.Equal(t, []string{"1000", "1001"}, s.Default)
			}},
		{name: "Default Off", s: &s{}, expectedError: false, m: map[string]string{"require": "10", "default": "4,5"},
			a: func(s *s) {
				assert.Equal(t, []string{"10"}, s.Required)
				assert.Equal(t, []string{"4", "5"}, s.Default)
			}},
		{name: "Default On + unprotected", s: &s{Default: []string{"50", "51"}}, expectedError: false, m: map[string]string{"require": "10"},
			a: func(s *s) {
				assert.Equal(t, []string{"10"}, s.Required)
				assert.Equal(t, []string{"1000", "1001"}, s.Default)
			}},
		{name: "private default protected 1", s: &s{privateDefaultProtected: []string{"5", "6"}}, expectedError: false, m: map[string]string{"require": "10"},
			a: func(s *s) {
				assert.Equal(t, []string{"5", "6"}, s.privateDefaultProtected)
				assert.Equal(t, []string{"1000", "1001"}, s.Default)
			}},
		{name: "private default protected 2", s: &s{}, expectedError: false, m: map[string]string{"require": "10"},
			a: func(s *s) {
				assert.Equal(t, []string{"1000", "1001"}, s.privateDefaultProtected)
				assert.Equal(t, []string{"1000", "1001"}, s.Default)
				assert.Equal(t, []string{"10"}, s.Required)
			}},
		{name: "private default protected 3", s: &s{}, expectedError: false, m: map[string]string{"require": "10", "privateDefaultProtected": "5"},
			a: func(s *s) {
				assert.Equal(t, []string{"5"}, s.privateDefaultProtected)
				assert.Equal(t, []string{"1000", "1001"}, s.Default)
				assert.Equal(t, []string{"10"}, s.Required)
			}},
		{name: "nested", s: &s{}, expectedError: false, m: map[string]string{"require": "10", "nested": "100,110"},
			a: func(s *s) {
				assert.Equal(t, []string{"100", "110"}, s.Nested.Value)
				assert.Equal(t, []string{"10"}, s.Required)
				assert.Equal(t, []string{"1000", "1001"}, s.Default)
			}},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := Bind(test.m, test.s)
			assert.Equal(t, test.expectedError, err != nil)
			test.a(test.s)
		})
	}
}

func TestBoolSlice(t *testing.T) {
	type s struct {
		Public                  []bool `annotation:"public"`
		private                 []bool `annotation:"private"`
		Protected               []bool `annotation:"protected, protected=true"`
		Required                []bool `annotation:"require, require=true"`
		Default                 []bool `annotation:"default, default=[true,true]"`
		privateDefaultProtected []bool `annotation:"privateDefaultProtected, default=[true,true], protected=true"`
		Nested                  struct {
			Value []bool `annotation:"nested, default=[true,true]"`
		}
	}

	var tests = []struct {
		name          string
		m             map[string]string
		s             *s
		expectedError bool
		a             func(s *s)
	}{
		{name: "Public", s: &s{}, expectedError: false, m: map[string]string{"require": "true,true", "public": "true,true"},
			a: func(s *s) {
				assert.Equal(t, []bool{true, true}, s.Public)
				assert.Equal(t, []bool{true, true}, s.Required)
				assert.Equal(t, []bool{true, true}, s.Default)
			}},
		{name: "private", s: &s{}, expectedError: false, m: map[string]string{"require": "true", "private": "true"},
			a: func(s *s) {
				assert.Equal(t, []bool{true}, s.private)
				assert.Equal(t, []bool{true}, s.Required)
				assert.Equal(t, []bool{true, true}, s.Default)
			}},
		{name: "Protected Off", s: &s{}, expectedError: false, m: map[string]string{"require": "true,true", "protected": "true,true"},
			a: func(s *s) {
				assert.Equal(t, []bool{true, true}, s.Protected)
				assert.Equal(t, []bool{true, true}, s.Required)
			}},
		{name: "Protected On", s: &s{Protected: []bool{true, true}}, expectedError: false, m: map[string]string{"require": "true", "protected": "true,true"},
			a: func(s *s) {
				assert.Equal(t, []bool{true, true}, s.Protected)
				assert.Equal(t, []bool{true}, s.Required)
				assert.Equal(t, []bool{true, true}, s.Default)
			}},
		{name: "Protected On Empty", s: &s{Protected: []bool{}}, expectedError: false, m: map[string]string{"require": "true", "protected": "true,true"},
			a: func(s *s) {
				assert.Equal(t, []bool{}, s.Protected)
				assert.Equal(t, []bool{true}, s.Required)
				assert.Equal(t, []bool{true, true}, s.Default)
			}},
		{name: "Protected On Nil", s: &s{Protected: nil}, expectedError: false, m: map[string]string{"require": "true", "protected": "true,true"},
			a: func(s *s) {
				assert.Equal(t, []bool{true, true}, s.Protected)
				assert.Equal(t, []bool{true}, s.Required)
				assert.Equal(t, []bool{true, true}, s.Default)
			}},
		{name: "Unprotected", s: &s{Required: []bool{true}}, expectedError: false, m: map[string]string{"require": "true,true"},
			a: func(s *s) {
				assert.Equal(t, []bool{true, true}, s.Required)
				assert.Equal(t, []bool{true, true}, s.Default)
			}},
		{name: "Required On", s: &s{}, expectedError: false, m: map[string]string{"require": "true,true"},
			a: func(s *s) {
				assert.Equal(t, []bool{true, true}, s.Required)
				assert.Equal(t, []bool{true, true}, s.Default)
			}},
		{name: "Required On Empty", s: &s{}, expectedError: false, m: map[string]string{"require": ""},
			a: func(s *s) {
				assert.Equal(t, []bool{}, s.Required)
				assert.Equal(t, []bool{true, true}, s.Default)
			}},
		{name: "Required Off (Nil)", s: &s{}, expectedError: true, m: map[string]string{},
			a: func(s *s) {}},
		{name: "Default On", s: &s{}, expectedError: false, m: map[string]string{"require": "true"},
			a: func(s *s) {
				assert.Equal(t, []bool{true}, s.Required)
				assert.Equal(t, []bool{true, true}, s.Default)
			}},
		{name: "Default Off", s: &s{}, expectedError: false, m: map[string]string{"require": "true", "default": "true,true"},
			a: func(s *s) {
				assert.Equal(t, []bool{true}, s.Required)
				assert.Equal(t, []bool{true, true}, s.Default)
			}},
		{name: "Default On + unprotected", s: &s{Default: []bool{true, true}}, expectedError: false, m: map[string]string{"require": "true"},
			a: func(s *s) {
				assert.Equal(t, []bool{true}, s.Required)
				assert.Equal(t, []bool{true, true}, s.Default)
			}},
		{name: "private default protected 1", s: &s{privateDefaultProtected: []bool{true, true}}, expectedError: false, m: map[string]string{"require": "true"},
			a: func(s *s) {
				assert.Equal(t, []bool{true, true}, s.privateDefaultProtected)
				assert.Equal(t, []bool{true, true}, s.Default)
			}},
		{name: "private default protected 2", s: &s{}, expectedError: false, m: map[string]string{"require": "true"},
			a: func(s *s) {
				assert.Equal(t, []bool{true, true}, s.privateDefaultProtected)
				assert.Equal(t, []bool{true, true}, s.Default)
				assert.Equal(t, []bool{true}, s.Required)
			}},
		{name: "private default protected 3", s: &s{}, expectedError: false, m: map[string]string{"require": "true", "privateDefaultProtected": "true"},
			a: func(s *s) {
				assert.Equal(t, []bool{true}, s.privateDefaultProtected)
				assert.Equal(t, []bool{true, true}, s.Default)
				assert.Equal(t, []bool{true}, s.Required)
			}},
		{name: "nested", s: &s{}, expectedError: false, m: map[string]string{"require": "true", "nested": "true,true"},
			a: func(s *s) {
				assert.Equal(t, []bool{true, true}, s.Nested.Value)
				assert.Equal(t, []bool{true}, s.Required)
				assert.Equal(t, []bool{true, true}, s.Default)
			}},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := Bind(test.m, test.s)
			assert.Equal(t, test.expectedError, err != nil)
			test.a(test.s)
		})
	}
}
